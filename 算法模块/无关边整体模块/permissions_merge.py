import numpy as np
from scipy import optimize
import math

def GraphMerge(n,evalDict,normalDict):
    """
    :param n: 恶意图的个数
    :param evalDict: 恶意图字典
    :param normalDict: 正常图字典
    :return: 最终恶意字典
    """
    commonEdge = {}
    disjointEdge = {}
    finalEval = {}
    for i in range(n):
        #获得共用边集和不相交边集
        for edge,value in evalDict[i].items():
            #注意获得的边是原始元组，没有处理顶点顺序问题，如果后续出现问题，这里可能会需要修改
            flag = 0
            if(value != 0):
                flag = flag + 1
                max = value
                min = value
                mid = value
                for j in range(i+1,n):
                    if(edge in evalDict[j]):
                        if(evalDict[j][edge] != 0):
                            #说明在第j个图里存在这条边
                            flag = flag + 1
                            if(evalDict[j][edge] > max):
                                max = evalDict[j][edge]
                            elif(evalDict[j][edge] < min):
                                min = evalDict[j][edge]
                            else:
                                mid = evalDict[j][edge]
                if(flag >= 2):
                    #赋初值
                    commonEdge[edge] = {'max':max,'mid':mid,'min':min}
                else:
                    disjointEdge[edge] = value


    for edge,value in commonEdge.items():
        #权重选择

        if(edge in normalDict):
            #其实在这里我有点搞不清楚，即公共边在上一个循环里面只在三个恶意图里查找了，并不能保证这个公共边也在正常图中，
            # 但是伪代码中并没有相关解释
            if(value['min'] > normalDict[edge]):
                finalEval[edge] = min
            elif(value['max'] < normalDict[edge]):
                finalEval[edge] = max
            else:
                #计算线性规划,调用numpy包
                #这里只适用于三个图的情况
                a1 = (value['max'] + value['mid'] + value['min'])/(value['max'] + value['mid'] + value['min'] + normalDict[edge])
                a2 = 1 - a1
                z = np.array([(1)*(a1*(value['max'] + value['mid'] + value['min']) - a2*normalDict[edge])])
                mi_bound = (value['min'],value['max'])
                #线性规划
                res = optimize.linprog(z,bounds=mi_bound)
                finalEval[edge] = res.x[0]
        else:
            #在这里认为正常图中这条边权重为0，一定比min还小
            finalEval[edge] = min

    # v = disjointEdge.values()
    # v = sorted(v,reverse = True)
    for edge,value in disjointEdge.items():
        finalEval[edge] = value


    return finalEval





