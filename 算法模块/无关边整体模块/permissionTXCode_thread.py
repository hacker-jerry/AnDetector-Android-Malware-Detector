# coding=UTF-8
from multiprocessing.dummy import freeze_support

import permissions_merge as pm
import code_final as cf
import os
import re
import string
import math
import copy
import time
import threading
from multiprocessing import Pool

# w = {}
# num= []
# for root,dirs,files in os.walk(r"../软件apk权限清单/apk/恶意软件2018"):
#     w[0] = {}
#     for file in files:
#         f = open(os.path.join(root,file))
#         permissions = []
#         for line in f.readlines():
#             permission = re.match(r'uses-permission: name=\'(.*)\'',line)
#             if(permission):
#                 #  print(permission.groups()[0])
#                 permissions.append(permission.groups()[0])
#         f.close()
#         permissions = list(set(permissions))
#         w[0] = cf.draw_map(permissions,w[0])
#     num.append(len(files))
#
#
# for root,dirs,files in os.walk(r"../软件apk权限清单/apk/恶意软件2019"):
#     w[1] = {}
#     for file in files:
#         f = open(os.path.join(root,file))
#         permissions = []
#         for line in f.readlines():
#             permission = re.match(r'uses-permission: name=\'(.*)\'',line)
#             if(permission):
#                 #  print(permission.groups()[0])
#                 permissions.append(permission.groups()[0])
#         f.close()
#         permissions = list(set(permissions))
#         w[1] = cf.draw_map(permissions,w[1])
#     num.append(len(files))
#
# for root,dirs,files in os.walk(r"../软件apk权限清单/apk/恶意软件2020"):
#     w[2] = {}
#     for file in files:
#         f = open(os.path.join(root,file))
#         permissions = []
#         for line in f.readlines():
#             permission = re.match(r'uses-permission: name=\'(.*)\'',line)
#             if(permission):
#                 #  print(permission.groups()[0])
#                 permissions.append(permission.groups()[0])
#         f.close()
#         permissions = list(set(permissions))
#         w[2] = cf.draw_map(permissions,w[2])
#     num.append(len(files))
#
# for root,dirs,files in os.walk(r"../软件apk权限清单/apk/normaltest"):
#     n = {}
#     for file in files:
#         f = open(os.path.join(root,file))
#         permissions = []
#         for line in f.readlines():
#             permission = re.match(r'uses-permission: name=\'(.*)\'',line)
#             if(permission):
#                 #  print(permission.groups()[0])
#                 permissions.append(permission.groups()[0])
#         f.close()
#         permissions = list(set(permissions))
#         n = cf.draw_map(permissions,n)
#     nor_num = len(files)
#
# for key in n.keys():
#     n[key] = (float)(n[key])/nor_num
#
# for i in range(3):
#     for key in w[i].keys():
#          w[i][key]=(float)(w[i][key])/num[i]
#
#
# eval = {}
# eval = pm.GraphMerge(3,w,n)#n是正常软件
#测试集的数量

# evaldic = open("evaldic.txt",'w+')
# normaldic = open("normal.txt",'w+')
# evaldic.write(str(eval))
# normaldic.write(str(n))
# evaldic.close()
# normaldic.close()

en = 0
nn = 0
#这是用上面软件集生成的图
evaltxt = open("evaldic.txt",'r')
normaltxt = open("normal.txt",'r')
#用eval函数可以自动识别str里的数据类型
evaldic = eval(evaltxt.read())
normaldic = eval(normaltxt.read())
evaltxt.close()
normaltxt.close()

def NormalDetection(e,n):
    en = 0
    nn = 0
    # global root, dirs, files, file, score, f, permissions, line, permission, ys_no, en, nn
    for root, dirs, files in os.walk(r"../软件apk权限清单/apk/正常软件1"):
        #这里是正常软件的测试集路径
        for file in files:
            score = {}
            f = open(os.path.join(root, file))
            permissions = []
            for line in f.readlines():
                permission = re.match(r'uses-permission: name=\'(.*)\'', line)
                if (permission):
                    #  print(permission.groups()[0])
                    permissions.append(permission.groups()[0])
            f.close()
            permissions = list(set(permissions))
            score = cf.csum_score(e, n, permissions)
            if score['evil_score'] > score['normal_score']:
                ys_no = "Malware!"
                en = en + 1
                # print(file + "  " + ys_no)
            else:
                ys_no = "Normalware!"
                nn = nn + 1
                # print(file + "  " + ys_no)

            # print(file+"  "+ys_no)
            # print(score)
    # print("正常的软件")
    # print("normal: " + str(nn))
    # print("eval: " + str(en))
    TNR = nn / (nn + en)
    return TNR


TNR = NormalDetection(evaldic,normaldic)


def evalDetection(e,n):
    en = 0
    nn = 0
    # global root, dirs, files, file, score, f, permissions, line, permission, ys_no, en, nn
    for root, dirs, files in os.walk(r"../软件apk权限清单/apk/恶意软件集"):
        for file in files:
            score = {}
            f = open(os.path.join(root, file))
            permissions = []
            for line in f.readlines():
                permission = re.match(r'uses-permission: name=\'(.*)\'', line)
                if (permission):
                    #  print(permission.groups()[0])
                    permissions.append(permission.groups()[0])
            f.close()
            permissions = list(set(permissions))
            score = cf.csum_score(e, n, permissions)
            if score['evil_score'] > score['normal_score']:
                ys_no = "Malware!"
                en = en + 1
                # print(file + "  " + ys_no)
            else:
                ys_no = "Normalware!"
                nn = nn + 1
    # print("恶意的软件")
    # print("normal: " + str(nn))
    # print("eval: " + str(en))
    TPR = en / (en + nn)
    return TPR


TPR = evalDetection(evaldic,normaldic)




def irrelevantEdge(flag,partnum):
    """
    无关边识别并删除
    :return: 最大无关边集
    """
    Ereduced = []  # 无关边集
    Elist = {}
    print(f'(进程: {flag}： 开始时间：{time.strftime("%Y-%m-%d %H:%M:%S")}')
    count = 0
    lowlimit=flag*(len(evaldic.items())//partnum)
    uplimit=(flag+1)*(len(evaldic.items())//partnum)
    if flag==(partnum-1):
        uplimit = len(list(evaldic.items()))+1

    for edge,value in list(evaldic.items())[lowlimit:uplimit]:
        count = count + 1
        #因为是无向图，相邻的两个元素属于一条边
        if(count%2==0):
            continue
        evaltest = copy.copy(evaldic)
        TestEdgeValue = evaltest.pop(edge)
        TestTPR = evalDetection(evaltest,normaldic)
        TestTNR = NormalDetection(evaltest,normaldic)
        if(TestTPR >= TPR and TestTNR >= TNR):
            Ereduced.append(edge)
            if(edge in normaldic):
                #如果在正常图中存在
                Elist[edge] = math.fabs(normaldic[edge] - TestEdgeValue)
            else:
                Elist[edge] = TestEdgeValue
        else:
            continue
        number = len(Ereduced)
        print(str(number) +"/"+str(len(list(evaldic.items())[lowlimit:uplimit])))

    count = 0
    for edge,value in list(normaldic.items())[lowlimit:uplimit]:
        count = count + 1
        # 因为是无向图，相邻的两个元素属于一条边
        if (count % 2 == 0):
            continue
        normaltest = copy.copy(normaldic)
        TestEdgeValue = normaltest.pop(edge)
        TestTPR = evalDetection(evaldic,normaltest)
        TestTNR = NormalDetection(evaldic,normaltest)
        if(TestTPR >= TPR and TestTNR >= TNR):
            Ereduced.append(edge)
            if(edge in evaldic):
                #如果在eval图中存在
                Elist[edge] = math.fabs(normaldic[edge] - TestEdgeValue)
            else:
                Elist[edge] = TestEdgeValue
        else:
            continue
        number = len(Ereduced)
        print(str(number) + "/" + str(len(list(normaldic.items())[lowlimit:uplimit])))
    print(f'进程：{flag} 结束时间：{time.strftime("%Y-%m-%d %H:%M:%S")}')
    return Ereduced,Elist

def mapfunc(arg):
    #由于map函数只能传一个参数，因此将双参数函数封装成单参数
    return irrelevantEdge(arg[0],arg[1])

if __name__ == '__main__':

    #初始化线程
    #partnum=100
    print(f'主进程开始时间：{time.strftime("%Y-%m-%d %H:%M:%S")}')
    numpool = 1
    p=Pool(numpool)
    Ereduce = []  # 无关边集
    Eli = {}
    arg = []
    for i in range(numpool):
        # ee = p.apply_async(irrelevantEdge,args=(i,5))
        # Ereduce.append(ee.get())
        arg.append((i,numpool))


    res = p.map(mapfunc,arg)#只能单参数接受多参返回，然后根据顺序各自分配

    for i in range(numpool):
        Ereduce.append(res[i][0])#针对list添加值
        Eli.update(res[i][1])#针对dic添加值


    # p.close()
    # p.join()# 由于map自带close和join，所以如果重复添加会有问题，这个是apply_async需要的
    Elisttxt = open("ElistTxtall.txt","w+")
    Elisttxt.write(str(Eli))
    Elisttxt.close()
    Ereducedtxt = open("EreducedTxtall.txt","w+")
    Ereducedtxt.write(str(Ereduce))
    Ereducedtxt.close()
