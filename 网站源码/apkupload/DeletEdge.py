import copy
import os
import re
import code_final as cf
en = 0
nn = 0
#这是用上面软件集生成的图
evaltxt = open("evaldic1.txt",'r')
normaltxt = open("normal1.txt",'r')

#用eval函数可以自动识别str里的数据类型
evaldic = eval(evaltxt.read())
normaldic = eval(normaltxt.read())
evaltxt.close()
normaltxt.close()

def NormalDetection(e,n):
    en = 0
    nn = 0
    # global root, dirs, files, file, score, f, permissions, line, permission, ys_no, en, nn
    for root, dirs, files in os.walk(r"Andro_Dumpsys_Normal_little"):
        #这里是正常软件的测试集路径
        for file in files:
            score = {}
            f = open(os.path.join(root, file))
            permissions = []
            for line in f.readlines():
                permission = re.match(r'uses-permission: name=\'(.*)\'', line)
                if (permission):
                    #  print(permission.groups()[0])
                    permissions.append(permission.groups()[0])
            f.close()
            permissions = list(set(permissions))
            score = cf.csum_score(e, n, permissions)
            if score['evil_score'] > score['normal_score']:
                ys_no = "Malware!"
                en = en + 1
                # print(file + "  " + ys_no)
            else:
                ys_no = "Normalware!"
                nn = nn + 1
                # print(file + "  " + ys_no)

            # print(file+"  "+ys_no)
            # print(score)
    # print("正常的软件")
    # print("normal: " + str(nn))
    # print("eval: " + str(en))
    TNR = nn / (nn + en)
    return TNR


TNR = NormalDetection(evaldic,normaldic)


def evalDetection(e,n):
    en = 0
    nn = 0
    # global root, dirs, files, file, score, f, permissions, line, permission, ys_no, en, nn
    for root, dirs, files in os.walk(r"Andro_Dumpsys_Malware2"):
        for file in files:
            score = {}
            f = open(os.path.join(root, file))
            permissions = []
            for line in f.readlines():
                permission = re.match(r'uses-permission: name=\'(.*)\'', line)
                if (permission):
                    #  print(permission.groups()[0])
                    permissions.append(permission.groups()[0])
            f.close()
            permissions = list(set(permissions))
            score = cf.csum_score(e, n, permissions)
            if score['evil_score'] > score['normal_score']:
                ys_no = "Malware!"
                en = en + 1
                # print(file + "  " + ys_no)
            else:
                ys_no = "Normalware!"
                nn = nn + 1
    # print("恶意的软件")
    # print("normal: " + str(nn))
    # print("eval: " + str(en))
    TPR = en / (en + nn)
    return TPR


TPR = evalDetection(evaldic,normaldic)


with open("ElistTxtall1.txt","r") as f2:
    Elist=f2.read()
#将Elist 按照值递增的顺序排序
Elist=dict(sorted((eval(Elist)).items(),key=lambda x:x[1]))
print(Elist)
Elist_final=[]
#定义精确度
precision=13
#最开始的权重差的和
weight_sum=round(0,precision)
for key in Elist:
    weight_sum+=Elist[key]
weight_sum=round(weight_sum,precision)
#设置最开始的上限和下限
up_limit=weight_sum
low_limit=round(0,precision)
count=0
#寻找最大无关边的函数，利用递归调用
def Deletedge(low_limit1,up_limit1):
    global count
    global up_limit_final
    #如果上下限相同，则满足条件，为最终的上限赋值，函数返回
    if(low_limit1==up_limit1):
        up_limit_final=up_limit1
        return
    else:
        normaltest = copy.copy(normaldic)
        evaltest = copy.copy(evaldic)
        weight_sum1=round(0,precision)
        del_edge=[]
        #用来得到本轮需要删除的边
        for edge in Elist:
            if (weight_sum1>up_limit1):
                break
            else:
                weight_sum1+=Elist[edge]
                weight_sum1=round(weight_sum1,precision)
                del_edge.append(edge)
        #删除这些边
        for edge in del_edge:
            if edge in normaldic.keys():
                normaltest.pop(edge)
            if edge in evaldic.keys():
                evaltest.pop(edge)
        #计算删除后的TPR和TNR
        TestTPR = evalDetection(evaltest,normaltest)
        TestTNR = NormalDetection(evaltest,normaltest)
        if(TestTPR >= TPR and TestTNR >= TNR):
            #如果TPR和TNR都没有下降并且为第一轮，则直接返回，说明可以删除所有无关边
            if(count==0):
                up_limit_final=up_limit1
                return
            #如果不是第一轮，由于都没有下降，因此下限变为本轮传入的上限，上限变为上一轮的上限，即二倍
            else:
                low_limit2=round(up_limit1,precision)
                up_limit2=round(2*up_limit1,precision)
        #如果下降了，那么下限依旧不变，上限变为之前的一半
        else:
            low_limit2=round(low_limit1,precision)
            up_limit2=round((float)(up_limit1)/2,precision)
    count += 1
    Deletedge(low_limit2,up_limit2)
#最终的权重差的和
weight_sum_final=round(0,precision)
#最终的上限
up_limit_final=round(0,precision)
Deletedge(low_limit,up_limit)
#如果最终的上限就是开始的上限，则Elist就是最大无关边集
if (up_limit_final==up_limit):
    Elist_final=list(Elist.keys())
#否则，删除权重差的和不超过最终上限的所有边，这些边即为最大无关边集
else:
    for edge in Elist:
        if (weight_sum_final>up_limit_final):
            break
        else:
            weight_sum_final+=Elist[edge]
            weight_sum_final=round(weight_sum_final,precision)
            Elist_final.append(edge)
print("最终的上限为：")
print(up_limit_final)
print("最终的最大无关边集为：")
print(Elist_final)
#消除最大无关边集
normaltest = copy.copy(normaldic)
evaltest = copy.copy(evaldic)
for edge in Elist_final:
    if edge in normaldic.keys():
        normaltest.pop(edge)
    if edge in evaldic.keys():
        evaltest.pop(edge)
print("消除前的TPR和TNR：")
print(TPR)
print(TNR)
TestTPR = evalDetection(evaltest, normaltest)
TestTNR = NormalDetection(evaltest, normaltest)
print("消除后的TPR和TNR：")
print(TestTPR)
print(TestTNR)
print("之前的正常图和恶意图字典长度：")
print(len(normaldic))
print(len(evaldic))
print("消除后的正常图和恶意图字典长度：")
print(len(normaltest))
print(len(evaltest))
with open("normalnew.txt",'w') as f3:
    f3.write(str(normaltest))
with open("evalnew.txt",'w') as f4:
    f4.write(str(evaltest))